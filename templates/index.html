<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DHS 2026 Chatbot</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
        }

        .message-card {
            margin-bottom: 1.5rem;
            border-radius: 1rem;
            padding: 1rem 1.5rem;
            max-width: 80%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            animation: fadeIn 0.3s ease-in-out;
        }

        .user-message {
            background-color: #0d6efd;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.25rem;
        }

        .bot-message {
            background-color: white;
            color: #212529;
            margin-right: auto;
            border-bottom-left-radius: 0.25rem;
            border: 1px solid #dee2e6;
        }

        .input-area {
            background-color: white;
            border-top: 1px solid #dee2e6;
            padding: 2rem;
            border-radius: 1rem 1rem 0 0;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.03);
        }

        .input-container {
            max-width: 900px;
            margin: 0 auto;
            position: relative;
        }

        .spinner-border {
            width: 1.5rem;
            height: 1.5rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>

<body>

    <!-- Header -->
    <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom py-3 sticky-top">
        <div class="container">
            <a class="navbar-brand fw-bold text-primary" href="#">
                <i class="bi bi-chat-dots-fill me-2"></i>DHS 2026 Agent
            </a>
            <span class="badge bg-light text-secondary rounded-pill border">Beta</span>
        </div>
    </nav>

    <!-- Chat Area -->
    <div class="chat-container" id="chat-history">
        <!-- Welcome Message -->
        <div class="message-card bot-message">
            <h5 class="fw-bold mb-2">ðŸ‘‹ Welcome!</h5>
            <p class="mb-0">I'm your DHS 2026 assistant. How can I help you today?</p>
        </div>
    </div>

    <!-- Input Area -->
    <div class="input-area">
        <div class="input-container">
            <form id="chat-form" class="d-flex gap-2">
                <input type="text" class="form-control form-control-lg shadow-sm border-0 bg-light" id="user-input"
                    placeholder="Type your message here..." autocomplete="off" required>
                <button type="submit" class="btn btn-primary btn-lg px-4 shadow-sm" id="send-btn">
                    Send
                </button>
            </form>
            <div class="text-center mt-2">
                <small class="text-muted">AI can make mistakes. Please verify important information.</small>
            </div>
        </div>
    </div>

    <script>
        const chatForm = document.getElementById('chat-form');
        const userInput = document.getElementById('user-input');
        const chatHistory = document.getElementById('chat-history');
        const sendBtn = document.getElementById('send-btn');

        // Generate random session IDs for memory (simplified for this demo)
        const mem0UserId = "user_" + Math.random().toString(36).substr(2, 9);
        const mem0SessionId = "session_" + Math.random().toString(36).substr(2, 9);

        // Scroll to bottom
        function scrollToBottom() {
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = userInput.value.trim();
            if (!message) return;

            // 1. Add user message
            const userMsgDiv = document.createElement('div');
            userMsgDiv.className = 'message-card user-message';
            userMsgDiv.textContent = message;
            chatHistory.appendChild(userMsgDiv);

            // Clear input & disable
            userInput.value = '';
            userInput.disabled = true;
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
            scrollToBottom();

            try {
                // 2. Send to backend
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_input: message,
                        mem0_user_id: mem0UserId,
                        mem0_session_id: mem0SessionId,
                        signed_in: false
                    })
                });

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                // 3. Get HTML response
                const htmlResponse = await response.text();

                // 4. Add bot response container
                const botMsgDiv = document.createElement('div');
                botMsgDiv.className = 'message-card bot-message content-html';
                chatHistory.appendChild(botMsgDiv);

                // 5. Typewriter effect
                simulateStreaming(botMsgDiv, htmlResponse);

            } catch (error) {
                console.error('Error:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'message-card bot-message text-danger';
                errorDiv.textContent = "Sorry, I encountered an error. Please try again.";
                chatHistory.appendChild(errorDiv);
            } finally {
                // Reset UI
                userInput.disabled = false;
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
                userInput.focus();
                // scrollToBottom called inside simulateStreaming
            }
        });

        function simulateStreaming(element, htmlContent) {
            // Create a temporary container to parse the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            // We want to extract text nodes and elements to stream them
            // For a simple "word by word" stream of the *text* content while preserving HTML structure,
            // it's complex. 
            // A simpler approach for "word to word as if we are streaming it" 
            // usually implies streaming the text.
            // If the HTML is complex (lists, bolding), we might want to reveal it carefully.

            // Approach: 
            // 1. If it's simple text wrapped in tags, we can stream the text.
            // 2. If it's complex HTML, we might need a more robust parser or just stream text content.

            // Given the user said "print the word to word", let's try a robust text + html streamer.
            // OR simpler: Just append words if it's mostly text.

            // Let's implement a word-by-word Revealer. 
            // NOTE: Since we receive HTML, stripping tags to stream text might lose formatting.
            // But streaming raw HTML tags looks bad (<, b, r, >...).

            // Better approach for "HTML":
            // Render the HTML invisible, then reveal words? No, hard to control.

            // Alternative:
            // RegEx split by tags and words.

            const tokenRegex = /(<[^>]*>|[^<>\s]+|\s+)/g;
            const tokens = htmlContent.match(tokenRegex) || [];

            let i = 0;

            function typeNext() {
                if (i < tokens.length) {
                    const token = tokens[i];

                    if (token.startsWith('<')) {
                        // It's an HTML tag, append immediately without delay
                        element.innerHTML += token;
                        // Determine if we need to scroll (rendering a tag might change height)
                        scrollToBottom();
                        i++;
                        typeNext(); // Recursive call immediately for tags
                    } else {
                        // It's text or whitespace, append and wait
                        element.innerHTML += token;
                        scrollToBottom();
                        i++;
                        setTimeout(typeNext, 100); // 20ms delay for text
                    }
                }
            }

            typeNext();
        }
    </script>
</body>

</html>